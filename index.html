<!DOCTYPE html>
<html lang="en">

<head>
	<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>System Profiler</title>
	<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<style>

		.spinner {
			width: 32px;
			height: 32px;
			border: 4px solid #ccc;
			border-top: 4px solid #007bff; /* Spinner color */
			border-radius: 50%;
			animation: spin 1s linear infinite;
			margin: auto;
		}

		@keyframes spin {
			0% {
				transform: rotate(0deg);
			}

			100% {
				transform: rotate(360deg);
			}
		}


		/* Container for icons at the top-right */
		.top-right-icons {
			position: fixed;
			top: 20px;
			right: 20px;
			display: flex;
			align-items: center;
			justify-content: flex-end;
			z-index: 1000;
			gap: 20px; /* Spacing between notification and export */
		}

		/* Notification Icon */
		.notification-icon {
			font-size: 24px;
			color: #e0e0e0;
			cursor: pointer;
			position: relative;
			display: flex;
			align-items: center;
			justify-content: center;
		}

			.notification-icon .notification-count {
				position: absolute;
				top: -8px;
				right: -8px;
				background-color: red;
				color: white;
				border-radius: 50%;
				padding: 2px 6px;
				font-size: 12px;
				font-weight: bold;
			}

		/* Export Report Button */
		.report-export .export-btn {
			background-color: #007bff;
			color: white;
			border: none;
			padding: 10px 15px;
			border-radius: 5px;
			cursor: pointer;
			display: flex;
			align-items: center;
			font-size: 16px;
		}

			.report-export .export-btn i {
				margin-right: 8px;
			}

			.report-export .export-btn:hover {
				background-color: #0056b3;
			}

		/* General Styles */
		body {
			font-family: 'Roboto', sans-serif;
			background-color: #121212;
			margin: 0;
			padding: 0;
			color: #e0e0e0;
		}

		h1 {
			color: #ffffff;
			text-align: center;
			margin-top: 20px;
		}


		.metrics-container {
			display: flex;
			flex-wrap: wrap;
			gap: 20px;
			margin-top: 20px;
		}


		.metrics-box {
			flex: 1;
			padding: 10px;
			border: 1px solid #ccc;
			background-color: #f7f7f7;
		}

		/*.metric-label {
			display: block;
			margin-bottom: 8px;
			font-family: Arial, sans-serif;
		}*/


		.metric-label {
			display: block;
			margin-bottom: 8px;
			font-family: Arial, sans-serif;
			white-space: normal; /* Ensure long text wraps */
			word-wrap: break-word; /* Break long words if needed */
			overflow-wrap: break-word; /* Better word breaking */
			width: 100%; /* Take full container width */
			box-sizing: border-box; /* Includes padding/border in width */
		}

		.container {
			display: flex;
			justify-content: space-between;
			margin: 20px;
		}

		.box-EntireScreen {
			background-color: #1e1e1e;
			padding: 20px;
			border-radius: 10px;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
			width: 100%; /* Full width */
			box-sizing: border-box; /* Include padding in width */
		}

		.box {
			background-color: #1e1e1e;
			padding: 0;
			border-radius: 12px;
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.7);
			width: 30%;
			color: #f5f5f5;
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			transition: box-shadow 0.3s ease;
		}

			.box:hover {
				box-shadow: 0 6px 25px rgba(0, 0, 0, 0.9);
			}

		.box-header {
			background: linear-gradient(135deg, #2e2e2e, #3a3a3a);
			padding: 16px 22px;
			cursor: pointer;
			user-select: none;
			font-weight: 600;
			font-size: 1rem;
			border-top-left-radius: 12px;
			border-top-right-radius: 12px;
			display: flex;
			align-items: center;
			justify-content: space-between;
			transition: background 0.3s ease;
		}

			.box-header:hover {
				background: linear-gradient(135deg, #3a3a3a, #4a4a4a);
			}

			.box-header span::before {
				content: '‚ñ∂';
				display: inline-block;
				margin-right: 10px;
				transform: rotate(90deg);
				transition: transform 0.3s ease;
			}

			.box-header.collapsed span::before {
				transform: rotate(0deg);
			}

		.box-content {
			padding: 20px 24px;
			display: none;
			animation: fadeIn 0.3s ease-in-out;
			background-color: #252525;
			border-bottom-left-radius: 12px;
			border-bottom-right-radius: 12px;
			font-size: 0.95rem;
			line-height: 1.6;
			color: #dcdcdc;
			/* Ensure it fills the container */
			width: 100%;
			box-sizing: border-box;
		}

		/* Fade-in animation */
		@keyframes fadeIn {
			from {
				opacity: 0;
				transform: translateY(-5px);
			}

			to {
				opacity: 1;
				transform: translateY(0);
			}
		}

		@keyframes fadeIn {
			from {
				opacity: 0;
			}

			to {
				opacity: 1;
			}
		}


		.button-container {
			text-align: left;
			margin-top: 20px;
		}

			.button-container button {
				background-color: #007bff;
				color: white;
				border: none;
				padding: 10px 20px;
				margin: 5px;
				border-radius: 5px;
				cursor: pointer;
			}

				.button-container button:hover {
					background-color: #0056b3;
				}

		.grid-container {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
			gap: 10px;
			width: 100vw;
			Full viewport width box-sizing: border-box;
			Ensure padding/margin doesn't break layout padding: 10px; Optional spacing
		}



		.modal-content::-webkit-scrollbar {
			width: 8px;
		}

		.modal-content::-webkit-scrollbar-thumb {
			background-color: #555;
			border-radius: 5px;
		}

		.grid-container_vertical {
			display: grid;
			grid-template-columns: 1fr; /* Single column */
			gap: 10px;
		}

		.grid-item {
			background-color: #2a2a2a;
			padding: 10px;
			border-radius: 5px;
			text-align: center;
			color: #e0e0e0;
		}

		.section-title {
			font-weight: bold;
			margin-top: 10px;
			color: #ffffff;
		}

		.clickable {
			color: #66b0ff;
			cursor: pointer;
		}

			.clickable:hover {
				text-decoration: underline;
			}

		/* Modal Styles */
		.modal {
			display: none;
			position: fixed;
			z-index: 999;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
			overflow: auto;
			background-color: rgba(0, 0, 0, 0.8);
			padding-top: 60px;
		}

		.modal-content {
			background-color: #1e1e1e;
			margin: auto;
			padding: 20px;
			border: 1px solid #444;
			width: 90%;
			max-height: 80vh;
			overflow-y: auto;
			border-radius: 10px;
			color: #e0e0e0;
			box-sizing: border-box;
		}

		.styled-table tr:hover {
			/*background-color: #f0f8ff;*/
			cursor: pointer;
		}

		button {
			padding: 8px 12px;
			border-radius: 4px;
			border: none;
			background-color: #007bff;
			color: white;
			cursor: pointer;
		}

			button:hover {
				background-color: #0056b3;
			}

		#aiTableSearch {
			border: 1px solid #888;
			border-radius: 4px;
			font-size: 14px;
		}


		.table-wrapper {
			max-height: 400px;
			overflow-y: auto;
			border: 1px solid #ccc;
		}

		.styled-table {
			width: 100%;
			border-collapse: collapse;
		}

			.styled-table th,
			.styled-table td {
				padding: 12px;
				border: 1px solid #ddd;
			}

			.styled-table th {
				background-color: #333;
				color: white;
			}

		/* Container for each issue type */
		.log-category {
			margin-bottom: 24px;
		}

		/* Header for the issue type */
		.category-header {
			font-size: 1.5rem;
			color: #fff59d;
			margin-bottom: 12px;
			border-left: 4px solid #007bff;
			padding-left: 12px;
		}

		/* Card-style container for log details */
		.log-card {
			background-color: #2b2b2b; /* Darker background */
			border: 1px solid #444; /* Subtle border contrast */
			color: #f0f0f0; /* Light text for contrast */
			padding: 16px;
			border-radius: 8px;
			box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.3); /* Deeper shadow for definition */
		}

		/* Suggestion box styling */
		.suggestion-box {
			background-color: #fff3cd;
			color: #856404;
			padding: 10px 12px;
			margin-top: 12px;
			border: 1px solid #ffeeba;
			border-radius: 4px;
		}

		/* Action buttons container */
		.action-buttons {
			margin-top: 12px;
		}

		/* Button styling */
		.action-button {
			background-color: #007bff;
			border: none;
			color: white;
			padding: 8px 14px;
			margin: 6px 8px 0 0;
			border-radius: 4px;
			cursor: pointer;
			font-size: 14px;
			transition: background-color 0.3s ease;
		}

			.action-button:hover {
				background-color: #0056b3;
			}


		.close-btn {
			color: #aaa;
			float: right;
			font-size: 28px;
			font-weight: bold;
			cursor: pointer;
		}

			.close-btn:hover {
				color: #000;
			}


		.close {
			color: #aaa;
			font-size: 28px;
			font-weight: bold;
			float: right;
			cursor: pointer;
		}

			.close:hover,
			.close:focus {
				color: #fff;
				text-decoration: none;
				cursor: pointer;
			}

		/* Chart Container */
		#metricsChart {
			max-width: 100%;
			margin-top: 20px;
		}

		/* Custom Select Dropdown */
		select {
			padding: 8px;
			border-radius: 5px;
			border: 1px solid #555;
			background-color: #2a2a2a;
			color: #e0e0e0;
		}

		/* Schedule Options */
		#interval-options,
		#daily-options {
			margin-left: 20px;
		}
	</style>
</head>

<body>

	<div id="critical-processes-dropdown" class="dropdown-content" style="display:none; position: absolute; top: 40px; right: 0; background-color: #1e1e1e; border: 1px solid #555; border-radius: 8px; padding: 10px; width: 300px; box-shadow: 0 4px 8px rgba(0,0,0,0.5);">
		<h4 style="margin-top: 0; color: #ffffff;">Critical Processes</h4>
		<ul id="process-list" style="list-style: none; padding: 0; margin: 0; max-height: 300px; overflow-y: auto;"></ul>
	</div>

	<div class="top-right-icons">
		<!-- Notification Icon -->
		<div class="notification-icon">
			<i class="fas fa-bell"></i> <!-- Notification icon -->
			<span class="notification-count">3</span> <!-- Example notification count -->
		</div>

		<!-- Export Report Button -->
		<div class="report-export">
			<button class="export-btn">
				<i class="fas fa-download"></i> Export Report
			</button>
		</div>
	</div>

	<!--<canvas id="cpuChart" width="600" height="300"></canvas>
	<div id="process-details" style="margin-top: 10px;"></div>-->

	<h1> System Profiler</h1>

	<!--<div class="button-container">
		<button onclick="analyzeData()">Analyze Data</button>
	</div>-->

	<div class="container">
		<div class="box-EntireScreen">
			<h3> Critical Metrices </h3>
			<!--<div class="grid-container" id="key-metrics">Loading...</div>-->
			<div class="grid-container" id="key-metrics">
				<div class="spinner"></div>
			</div>
		</div>
	</div>




	<div class="metrics-container">


		<div class="box">
			<div class="box-header" onclick="toggleBox(this)">
				<span>OS INFO</span>
			</div>
			<div class="box-content">
				<div class="grid-container_vertical" id="os-info">
					<div class="spinner"></div>

				</div>
				<!--<div class="button-container" style="display: flex; align-items: center; gap: 20px; margin-top: 20px; flex-wrap: wrap;">
				<button onclick="analyzeData()">Analyze Disk Usage Data</button>
			</div>-->
			</div>
		</div>


		<div class="box">
			<div class="box-header" onclick="toggleBox(this)">
				<span>Disk Stats</span>
			</div>
			<div class="box-content">
				<div class="grid-container_vertical" id="extended-metrics">
					<div class="spinner"></div>

				</div>
				<!--<div class="button-container" style="display: flex; align-items: center; gap: 20px; margin-top: 20px; flex-wrap: wrap;">
				<button onclick="analyzeData()">Analyze Disk Usage Data</button>
			</div>-->
			</div>
		</div>

		<div class="box">
			<div class="box-header" onclick="toggleBox(this)">
				<span>Network Capture</span>
			</div>
			<div class="box-content">
				<div class="grid-container_vertical" id="network-metrics">
					<div class="spinner"></div>

				</div>
				<!--<div class="button-container" style="display: flex; align-items: center; gap: 20px; margin-top: 20px; flex-wrap: wrap;">
				<button onclick="analyzeData()">Analyze Disk Usage Data</button>
			</div>-->
			</div>
		</div>

		<div class="box">
			<div class="box-header" onclick="toggleBox(this)">
				<span>I/O Latency</span>
			</div>
			<div class="box-content">
				<div class="grid-container_vertical" id="io-metrics">
					<div class="spinner"></div>

				</div>
				<!--<div class="button-container" style="display: flex; align-items: center; gap: 20px; margin-top: 20px; flex-wrap: wrap;">
				<button onclick="analyzeData()">Analyze Disk Usage Data</button>
			</div>-->
			</div>
		</div>

		<div class="box">
			<div class="box-header" onclick="toggleBox(this)">
				<span>Garbage Cycle Tracker</span>
			</div>
			<div class="box-content">
				<div class="grid-container_vertical" id="garbage-metrics">
					<div class="spinner"></div>

				</div>
				<!--<div class="button-container" style="display: flex; align-items: center; gap: 20px; margin-top: 20px; flex-wrap: wrap;">
				<button onclick="analyzeData()">Analyze Disk Usage Data</button>
			</div>-->
			</div>
		</div>


		<div class="box">
			<div class="box-header" onclick="toggleBox(this)">
				<span>üìà Metrics Visualization</span>
			</div>
			<div class="box-content">
				<select id="chart-type" onchange="updateChartType()">
					<option value="line">Line</option>
					<option value="bar">Bar</option>
					<option value="pie">Pie</option>
				</select>
				<canvas id="metricsChart" width="400" height="300"></canvas>
			</div>
		</div>


		<div class="box">
			<div class="box-header" onclick="toggleBox(this)">
				<span>AI ANALYSER</span>
			</div>
			<div class="box-content">
				<div class="grid-container_vertical" id="extended-cpu_metrics">
					<!--<div class="spinner"></div>-->

				</div>
				<div class="button-container" style="display: flex; align-items: center; gap: 20px; margin-top: 20px; flex-wrap: wrap;">
					<button onclick="analyzeDataAI()">Analyze</button>
					<!--<div id="modal-body">-->
					<!-- Injected content -->
					<!--</div>-->
				</div>

			</div>
		</div>


		<div id="ai-analysisModal" class="modal">
			<div class="modal-content">
				<span class="close" onclick="closeModal('ai-analysisModal')">&times;</span>

				<h3>üßê AI Analysis</h3>

				<div class="modal-actions" style="display: flex; gap: 20px; margin-bottom: 15px;">
					<button onclick="viewProcessDetails()">üß† Process Details</button>
					<button onclick="terminateSelectedProcess()">üõë Terminate Process</button>
					<button onclick="shutdownSystem()">‚èª Shutdown System</button>
					<button onclick="exportToCSV()">üì§ Export to CSV</button>
				</div>

				<div class="grid-container" id="ai-analysis"></div>
			</div>
		</div>



	</div>

	<!--Overview Model-->
	<div id="overview-modal" class="modal" style="display:none;">
		<div class="modal-content">
			<span class="close" onclick="closeModal('overview-modal')">&times;</span>
			<div id="overview-results"></div>
		</div>
	</div>

	<!-- Full Details Modal -->
	<div id="detailsModal" class="modal">
		<div class="modal-content">
			<span class="close" onclick="closeModal('detailsModal')">&times;</span>
			<h3>üìú Full System Details</h3>
			<pre id="full-details"></pre>
		</div>
	</div>

	<!-- Thread Lock Contention Modal -->
	<div id="threadModal" class="modal">
		<div class="modal-content">
			<span class="close" onclick="closeModal('threadModal')">&times;</span>
			<h3>üîê Thread Contention Details</h3>
			<div id="thread-detail-content"></div>
		</div>
	</div>

	<!-- Analysis Modal -->
	<div id="analysisModal" class="modal">
		<div class="modal-content">
			<span class="close" onclick="closeModal('analysisModal')">&times;</span>
			<h3>üßê OVER ALL SYSTEM METRICES VIEW</h3>			
			<div class="grid-container" id="analysis-results"></div>
		</div>
	</div>


	<div class="button-container" style="display: flex; align-items: center; gap: 20px; margin-top: 20px; flex-wrap: wrap;">
		<button onclick="analyzeData()">OVERALL VIEW.</button>

		<!-- Schedule Mode Controls -->
		<div style="display: flex; align-items: center; gap: 10px;">
			<label for="schedule-mode">Schedule Mode:</label>
			<select id="schedule-mode" onchange="toggleScheduleOptions()">
				<option value="manual">Manual</option>
				<option value="interval">Every X Minutes</option>
				<option value="daily">At Specific Time</option>
			</select>

			<span id="interval-options" style="display:none;">
				<label for="interval-minutes">Interval (min):</label>
				<input type="number" id="interval-minutes" min="1" value="5" style="width: 60px;" />
			</span>

			<span id="daily-options" style="display:none;">
				<label for="daily-time">Time:</label>
				<input type="time" id="daily-time" value="12:00" />
			</span>

			<button onclick="startSchedule()">Start Schedule</button>
			<button onclick="stopSchedule()">Stop</button>
		</div>
	</div>




	<div id="thread-modal" class="modal">
		<div class="modal-content">
			<span class="close-btn" onclick="closeThreadModal()">&times;</span>
			<div id="thread-details-container"></div>
		</div>
	</div>


	<script>


        loadOSInfo();
        async function loadOSInfo() {
            const osInfo = document.getElementById('os-info');
            osInfo.innerHTML = '<p>Loading...</p>';

            try {
                const response = await fetch('/get-osInfo');
                const data = await response.json();

                osInfo.innerHTML = '';

                for (const [key, value] of Object.entries(data)) {
                    const item = document.createElement('div');
                    item.className = 'p-3 border border-gray-200 rounded bg-gray-50';
                    item.innerHTML = `<strong class="text-gray-700">${key}:</strong> <span class="text-gray-900">${value}</span>`;
                    osInfo.appendChild(item);
                }
            } catch (err) {
                osInfo.innerHTML = '<p class="text-red-500">Failed to load OS info.</p>';
                console.error(err);
            }
        }



		const notificationIcon = document.querySelector('.notification-icon');
		const dropdown = document.getElementById('critical-processes-dropdown');
		const processList = document.getElementById('process-list');


		async function populateCriticalProcesses() {
			const res = await fetch("/analyze");
			const data = await res.json();


			processList.innerHTML = ""; // Clear old data

			const issues = (data.performance_issues || [])
				.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)) // Sort descending by timestamp
				.slice(0, 10); // Take top 10

			issues.forEach(issue => {
				const { message, timestamp, type, process_name, pid, partition } = issue;

				// Only include fields if they're defined and meaningful
				const lines = [
					`<strong>Type:</strong> ${type}`,
					message ? `<strong>Message:</strong> ${message}` : null,
					process_name ? `<strong>Process:</strong> ${process_name}` : null,
					typeof pid !== 'undefined' ? `<strong>PID:</strong> ${pid}` : null,
					partition ? `<strong>Partition:</strong> ${partition}` : null,
					timestamp ? `<strong>Timestamp:</strong> ${timestamp}` : null
				].filter(Boolean); // Remove null/undefined

				const li = document.createElement('li');
				li.style.marginBottom = '12px';
				li.innerHTML = lines.join("<br>");
				processList.appendChild(li);
			});
		}







		async function analyzeDataAI() {
			const button = event.target;
			
			try {
				const response = await fetch("/overview");
				if (!response.ok) throw new Error("Server error during diagnosis");

				const result = await response.json();
				const issues = Array.isArray(result) ? result : result.performance_issues || [];

				let container = document.getElementById("ai-analysis");
				if (!container) return;

				container.innerHTML = "";

				if (!issues.length) {
					container.innerHTML = `<div class="log-card"><p>No performance issues found ‚úÖ</p></div>`;
				} else {
					let html = `
					<div class="table-wrapper">
					<input type="text" id="aiTableSearch" placeholder="üîç Filter by PID, Pattern, Summary..." onkeyup="filterAnalysisTable()" style="margin-bottom: 10px; padding: 6px; width: 100%; max-width: 300px;">
			<table class="styled-table">
				<thead>
					<tr>
						<th>Select</th>
						<th>PID</th>
						<th>Cluster</th>
						<th>Pattern</th>
						<th>Detection</th>
						<th>Recommendation</th>
					</tr>
				</thead>
				<tbody>`;

					for (const item of issues) {
						const pid = item.PID || item.pid;
						html += `
				<tr>
					<td><input type="radio" name="selectedPid" value="${pid}"></td>
					<td>${pid}</td>
					<td>${item.Cluster || item.cluster}</td>
					<td>${item.Pattern || item.pattern}</td>
					<td>${item.Summary || item.summary}</td>
					<td>${item.recommendation || item.recommendation}</td>
				</tr>`;
					}

					html += "</tbody></table></div> ";
					container.innerHTML = html;
				}

				document.getElementById("ai-analysisModal").style.display = "block";

			} catch (error) {
				alert("Failed to analyze: " + error.message);
			} 
		}


		function filterAnalysisTable() {
			const input = document.getElementById("aiTableSearch");
			const filter = input.value.toLowerCase();
			const table = document.querySelector("#ai-analysis table");
			if (!table) return;

			const rows = table.querySelectorAll("tbody tr");
			rows.forEach(row => {
				const text = row.textContent.toLowerCase();
				row.style.display = text.includes(filter) ? "" : "none";
			});
		}



		function getSelectedPid() {
			const radio = document.querySelector("input[name='selectedPid']:checked");
			return radio ? radio.value : null;
		}

		function viewProcessDetails() {
			const pid = getSelectedPid();
			if (!pid) return alert("Select a process first.");

			fetch(`/aisummary?pid=${pid}`)
				.then(res => res.json())
				.then(data => {
					const issues = Array.isArray(data) ? data : data.performance_issues || [];
					const container = document.getElementById("ai-analysis");
					if (!container) return;

					if (!issues.length) {
						container.innerHTML = `<div class="log-card"><p>No summary found for PID ${pid} ‚ùå</p></div>`;
						return;
					}

					const issue = issues[0]; // Only one per PID
					const html = `
				<h4>üîç Process Detail for PID ${pid}</h4>
				<table class="styled-table">
					<tbody>
						<tr><th>Process Name</th><td>${issue.ProcessName}</td></tr>
						<tr><th>Suspicious Thread ID</th><td>${issue.SuspiciousThreadID}</td></tr>
						<tr><th>Total CPU Time (ms)</th><td>${issue.TotalCpuTimeMs}</td></tr>
						<tr><th>Pattern</th><td>${issue.DiagnosticSummary}</td></tr>
						<tr><th>Dump Path</th><td>${issue.DumpPath}</td></tr>
					</tbody>
				</table>
			`;

					container.innerHTML = html;
					document.getElementById("ai-analysisModal").style.display = "block";
				})
				.catch(err => alert("Error fetching process details: " + err));
		}


		function shutdownSystem() {
			
            if (!confirm("Are you sure you want to shut down the system?")) return;

            try {

                fetch("/shutdown-system", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ reason: "AI analysis triggered shutdown" })
                });                

            } catch (err) {
                alert("üö® Failed to send shutdown request: " + err.message);
            }
		}




		function terminateSelectedProcess() {
			const pid = getSelectedPid();
			if (!pid) return alert("Select a process to terminate.");

			fetch("/terminate-process", {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify({ pid: parseInt(pid) }) // üëà sending pid in request body
			})
				.then(res => res.json())
				.then(data => alert(data.message || "Process termination requested."))
				.catch(err => alert("Error terminating process: " + err));
		}






		function closeModal(id) {
			document.getElementById("ai-analysisModal").style.display = "none";
		}

	

		function closeModal() {
			document.getElementById("overviewModal").style.display = "none";
		}


		




		// Utility to format each entry into readable text
		function formatProfilerEntry(entry, index) {
			let report = `--- System Profiler Snapshot ${index + 1} ---\n`;
			report += `Timestamp: ${entry.timestamp}\n`;
			report += `CPU Usage: ${entry.cpu_metrics.cpu_usage_percent}% of ${entry.cpu_metrics.cpu_count} cores @ ${entry.cpu_metrics.cpu_frequency} MHz\n`;
			report += `Top Critical Processes:\n`;

			entry.cpu_metrics.critical_processes.forEach(proc => {
				report += ` - ${proc.name} (PID: ${proc.pid}) CPU: ${proc.cpu_percent}%, Mem: ${proc.memory_percent.toFixed(2)}%\n`;
			});

			report += `\nTop CPU Consumers:\n`;
			entry.cpu_deep_metrics.top_cpu_processes.forEach(proc => {
				report += ` - ${proc.name} (PID: ${proc.pid}) CPU: ${proc.cpu_percent}%\n`;
			});

			report += `\nTop Memory Consumers:\n`;
			entry.memory_deep_metrics.top_memory_processes.forEach(proc => {
				report += ` - ${proc.name} (PID: ${proc.pid}) Mem: ${proc.memory_percent.toFixed(2)}%\n`;
			});

			report += `\nDisk Usage:\n`;
			entry.disk_deep_metrics.disk_partitions.forEach(part => {
				report += ` - ${part.device} Used: ${(part.used / 1e9).toFixed(2)} GB (${part.percent}%) Free: ${(part.free / 1e9).toFixed(2)} GB\n`;
			});

			report += `\nSystem Info:\n`;
			report += ` - Current Time: ${entry.system_info.current_time}\n`;
			report += ` - Uptime (s): ${entry.system_info.uptime_seconds}\n`;
			report += ` - Battery: ${entry.system_info.battery_percent}% ${entry.system_info.power_plugged ? "(Plugged In)" : "(On Battery)"}\n`;

			report += `\nThread Metrics (Process: ${entry.thread_metrics.process_name}):\n`;
			report += ` - Active Threads: ${entry.thread_metrics.active_threads}\n`;
			report += ` - Blocking Threads: ${entry.thread_metrics.blocking_threads.join(", ")}\n`;
			entry.thread_metrics.thread_details.forEach(thread => {
				report += `   ‚Ä¢ Thread ${thread.thread_name} (ID: ${thread.ident}) ${thread.is_blocking ? "[Blocking]" : ""}\n`;
				report += `     Stack Trace:\n`;
				thread.stack_summary.forEach(line => {
					report += `       ${line}\n`;
				});
			});

			report += `\n-----------------------------\n\n`;
			return report;
		}

		// Export Report Button Click Event
		document.querySelector(".export-btn").addEventListener("click", async function () {
			try {
				const res = await fetch("/analyze");
				const profilerData = await res.json();

				const entries = profilerData.performance_issues; // ‚úÖ This is the actual array

				if (!Array.isArray(entries)) {
					throw new Error("Expected profilerData.performance_issues to be an array");
				}

				const reports = entries.map((entry, idx) => {
					let report = `--- Performance Issue ${idx + 1} ---\n`;
					report += `Type: ${entry.type}\n`;
					report += `Timestamp: ${entry.timestamp}\n`;
					report += `Message: ${entry.message}\n`;

					if (entry.type === "ThreadContention") {
						report += `Process: ${entry.process_name}\n`;
						report += `Thread: ${entry.thread_name}\n`;
						report += `Stack Summary:\n`;
						entry.stack_summary.forEach(line => {
							report += `  - ${line}\n`;
						});
					}

					report += `\n-----------------------------\n\n`;
					return report;
				});

				const reportContent = reports.join("\n");

				const blob = new Blob([reportContent], { type: "text/plain" });
				const url = URL.createObjectURL(blob);
				const a = document.createElement("a");
				a.href = url;
				a.download = "system_profiler_report.txt";
				a.click();
				URL.revokeObjectURL(url);
			} catch (error) {
				console.error("Error exporting report:", error);
			}
		});


		let scheduleTimer = null;


		function toggleScheduleOptions() {
			const mode = document.getElementById("schedule-mode").value;
			document.getElementById("interval-options").style.display = mode === "interval" ? "inline" : "none";
			document.getElementById("daily-options").style.display = mode === "daily" ? "inline" : "none";
		}

		function startSchedule() {
			stopSchedule(); // Ensure no duplicate timers

			const mode = document.getElementById("schedule-mode").value;

			if (mode === "interval") {
				const interval = parseInt(document.getElementById("interval-minutes").value, 10) || 5;
				scheduleTimer = setInterval(analyzeData, interval * 60 * 1000);
				alert(`Scheduled to run every ${interval} minute(s).`);
			} else if (mode === "daily") {
				const time = document.getElementById("daily-time").value;
				const [hours, minutes] = time.split(":").map(Number);

				function scheduleDailyRun() {
					const now = new Date();
					const nextRun = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes, 0, 0);
					if (nextRun <= now) nextRun.setDate(nextRun.getDate() + 1);

					const delay = nextRun - now;
					scheduleTimer = setTimeout(() => {
						analyzeData();
						scheduleDailyRun(); // Re-schedule for the next day
					}, delay);
				}

				scheduleDailyRun();
				alert(`Scheduled daily analysis at ${time}.`);
			} else {
				alert("Manual mode selected. Click 'Analyze Data' to run manually.");
			}
		}

		function stopSchedule() {

			clearInterval(scheduleTimer);
			scheduleTimer = null;
			alert("Prvious running schedule configuration is overrriden.");

		}

		async function fetchMetrics() {
			try {
				const res = await fetch("/metrics");
				const data = await res.json();

				// CPU Usage Calculation
				const cpuUsage = data.cpu_deep_metrics.cpu_usage_per_core.reduce((acc, usage) => acc + usage, 0) / data.cpu_deep_metrics.cpu_usage_per_core.length;

				// Create compact labels
						document.getElementById("key-metrics").innerHTML = `
																						<span class="metric-label">CPU Count: ${safe(data?.cpu_metrics?.cpu_count)}</span>
																						<span class="metric-label">CPU Usage: ${safe(data?.cpu_metrics?.cpu_usage_percent)}%</span>
																						<span class="metric-label">Memory Usage: ${safe(data?.memory_deep_metrics?.memory_stats?.percent, 2)}%</span>
																						<span class="metric-label">Disk Usage: ${safe(data?.disk_deep_metrics?.disk_usage?.percent, 2)}%</span>
																					`;

				document.getElementById("extended-metrics").innerHTML = `
																						<span class="metric-label">Disk Read latency: ${safe(data?.disk_deep_metrics?.disk_latency?.read_latency_seconds)}</span>
																						<span class="metric-label">Disk Write latency: ${safe(data?.disk_deep_metrics?.disk_latency?.write_latency_seconds)}</span>
																						<span class="metric-label">Disk Usage percentage: ${safe(data?.disk_deep_metrics?.disk_usage?.percent)}</span>
																						<span class="metric-label">Swap Memory Usage: ${safe(data?.memory_deep_metrics?.swap_usage?.percent, 2)}%</span>
																					`;

				document.getElementById("network-metrics").innerHTML = `
																					<span class="metric-label">Bytes received: ${safe(data?.network_metrics?.bytes_received)}</span>
																					<span class="metric-label">Bytes sent: ${safe(data?.network_metrics?.bytes_sent)}</span>
																					<span class="metric-label">Packets received: ${safe(data?.network_metrics?.packets_received)}</span>
																					<span class="metric-label">Packets sent: ${safe(data?.network_metrics?.packets_sent)}</span>
																				`;

				document.getElementById("io-metrics").innerHTML = `
																					<span class="metric-label">Disk Read bytes: ${safe(data?.disk_deep_metrics?.disk_io?.read_bytes)}</span>
																					<span class="metric-label">Disk Read Count: ${safe(data?.disk_deep_metrics?.disk_io?.read_count)}</span>
																					<span class="metric-label">Disk Write bytes: ${safe(data?.disk_deep_metrics?.disk_io?.write_bytes)}</span>
																					<span class="metric-label">Disk Write Count: ${safe(data?.disk_deep_metrics?.disk_io?.write_count)}</span>
																				`;

				document.getElementById("garbage-metrics").innerHTML = `
																					<span class="metric-label">Garbage Object Collected: ${safe(data?.garbage_collector_metrics?.collected_objects)}</span>
																					<span class="metric-label">GC Enabled: ${safe(data?.garbage_collector_metrics?.gc_enabled)}</span>
																					<span class="metric-label">Unreachable Objects: ${safe(data?.garbage_collector_metrics?.unreachable_objects)}</span>
																					<span class="metric-label">GC Duration: ${safe(data?.garbage_collector_metrics?.gc_duration_ms)}</span>
																					<span class="metric-label">Garbage Threshold: ${safe(data?.garbage_collector_metrics?.garbage_threshold)}</span>
																					<span class="metric-label">Generation Count: ${safe(data?.garbage_collector_metrics?.generation_counts)}</span>
																					<span class="metric-label">Tracked Object: ${safe(data?.garbage_collector_metrics?.total_tracked_objects)}</span>
																				`;



                updateChart(data);
				const metrics = data.cpu_deep_metrics;
				let html = "";

				// Top CPU Processes
				html += `<span class="metric-label"></span><br>`;
				metrics.top_cpu_processes.forEach(proc => {
					html += `<span class="metric-sub">${proc.name} (PID: ${proc.pid}) - CPU: ${proc.cpu_percent}%</span><br>`;
				});

				//document.getElementById("extended-cpu_metrics").innerHTML = html;

				
			} catch (error) {
				console.error("Error fetching metrics:", error);
			}
		}

		function safe(val, digits = 0) {
			return val != null ? (typeof val === "number" ? val.toFixed(digits) : val) : "N/A";
		}


		async function fetchThreadContention() {
			try {
				const res = await fetch("/analyze");
				const data = await res.json();
				let threadContentionHTML = "";

				const groupedByType = {};


				const suggestionMap = {
					"CPUProcess": {
						suggestion: "CPU Details ....",
						actions: [
							{ label: "Inspect Threads", action: "viewThreads" },
							/*{ label: "Launch CPU Profiler", action: "showCpuProfiler" }*/
						]
					},
					"Memory": {
						suggestion: "Memory details.",
						actions: [
							{ label: "Inspect Memory", action: "openMemoryProfiler" }
						]
					},
					"Disk": {
						suggestion: "Disk Details.",
						actions: [
							{ label: "Inspect Disk I/O", action: "openDiskProfiler" }
						]
					},
					"Unknown": {
						suggestion: "",
						actions: []
					}
				};

				// Group issues by type
				data.performance_issues.forEach(item => {
					const type = item.type || 'Unknown';
					if (!groupedByType[type]) {
						groupedByType[type] = [];
					}
					groupedByType[type].push(item);
				});

				// Helper to conditionally render a field
				const renderField = (label, value) => {
					if (!value || value === "Unknown") return "";
					return `<p><strong>${label}:</strong> ${value}</p>`;
				};

				// Build the HTML

				const allowedTypes = ["CPUProcess", "Memory", "Disk"];

				for (const [type, items] of Object.entries(groupedByType)) {
					if (!allowedTypes.includes(type)) continue;

					const latestItem = items.reduce((latest, current) => {
						return new Date(current.timestamp) > new Date(latest.timestamp) ? current : latest;
					}, items[0]);

					const suggestionBlock = suggestionMap[type] || suggestionMap["Unknown"];
					const actionButtons = suggestionBlock.actions.map(
						btn => `<button class="action-button" onclick="${btn.action}('${type}')">${btn.label}</button>`
					).join(" ");

					threadContentionHTML += `
														<div class="log-category">
															<h3 class="category-header">${type}</h3>
															<div class="log-card">
																<div class="action-buttons">
																	${actionButtons}
																</div>
															</div>
														</div>`;
				}
			
				document.getElementById("analysis-results").innerHTML = threadContentionHTML;
				toggleAnalysisModal();

			} catch (error) {
				console.error("Error fetching thread contention:", error);
			}
		}


		async function openMemoryProfiler(issueType) {
			const container = document.getElementById("thread-details-container");
			container.innerHTML = `<h4 class="category-header">Loading High Memory usage details...</h4>`;

			try {
				closeAllModals();
				document.getElementById("thread-modal").style.display = "block";

				const res = await fetch("/memoryInfo");
				const data = await res.json();

				const highMemoryProcesses = data.performance_issues.filter(item => item.type === "HighMemoryUsage");

				if (highMemoryProcesses.length === 0) {
					container.innerHTML = `<div class="log-card"><p>No High Memory usage entries found.</p></div>`;
					return;
				}

				let html = `<h4 class="category-header">High Memory Usage (${highMemoryProcesses.length})</h4>`;

				highMemoryProcesses.forEach((item, index) => {
					html += `
					<div class="log-card thread-entry">						
						<p><strong>Memory Usage:</strong> ${item.memory_usage_mb} MB</p>
						<p><strong>Process Name:</strong> ${item.process_name}</p>
						<p><strong>PID:</strong> ${item.pid}</p>
						<p><strong>Timestamp:</strong> ${new Date(item.timestamp).toLocaleString()}</p>
					</div>`;
				});

				container.innerHTML = html;

			} catch (err) {
				container.innerHTML = `<div class="log-card"><p>Error loading memory data: ${err.message}</p></div>`;
			}
		}




		let threadCache = {
			data: null,
			timestamp: 0,
			cacheDuration: 1200000 // 60 seconds in milliseconds
		};

		async function viewThreads(issueType) {
			const container = document.getElementById("thread-details-container");
			container.innerHTML = `<h4 class="category-header">Loading High CPU Threads...</h4>`;

			try {
				closeAllModals();
				document.getElementById("thread-modal").style.display = "block";

				const now = Date.now();

				let data;

				if (threadCache.data && now - threadCache.timestamp < threadCache.cacheDuration) {
					// Use cached data
					console.log("Using cached thread data");
					data = threadCache.data;
				} else {
					// Fetch fresh data
					const res = await fetch("/ThreadInfo");
					data = await res.json();

					// Store in cache
					threadCache.data = data;
					threadCache.timestamp = now;
					console.log("Fetched new thread data");
				}

				const highCpuThreads = data.performance_issues.filter(item => item.type === "HighCPUThread");

				if (highCpuThreads.length === 0) {
					container.innerHTML = `<div class="log-card"><p>No High CPU thread entries found.</p></div>`;
					return;
				}

				let threadHTML = `<h4 class="category-header">High CPU Threads (${highCpuThreads.length})</h4>`;

				highCpuThreads.forEach((item, index) => {
					threadHTML += `
					<div class="log-card thread-entry">						
						<p><strong>CPU Time:</strong> ${item.cpu_time?.toFixed(2)} sec</p>
						<p><strong>Thread Name:</strong> ${item.thread_name}</p>
						<p><strong>Process Name:</strong> ${item.process_name}</p>
						<p><strong>PID:</strong> ${item.pid}</p>
						<p><strong>Timestamp:</strong> ${new Date(item.timestamp).toLocaleString()}</p>						
					</div>`;
				});

				container.innerHTML = threadHTML;

			} catch (err) {
				container.innerHTML = `<div class="log-card"><p>Error loading thread data: ${err.message}</p></div>`;
			}
		}


		async function optimizeLocks() {
			try {
				const analyzeResponse = await fetch("/analyze");
				const analyzeData = await analyzeResponse.json();

				// Filter for CPUProcess type issues
				const cpuProcesses = analyzeData.performance_issues.filter(issue => issue.type === "CPUProcess");
				const payload = cpuProcesses;

				const optimizeResponse = await fetch("/optimize-locks", {
					method: "POST",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify(payload),
				});

				const optimizeResult = await optimizeResponse.json();
				const container = document.getElementById("thread-details-container");

				if (optimizeResult.status === "error") {
					container.innerHTML = `
			<div class="log-card">
			  <h4 class="category-header">Optimization Error</h4>
			  <p>${optimizeResult.message}</p>
			</div>`;
				} else if (Array.isArray(optimizeResult) && optimizeResult.length > 0) {
					// Build content for all results
					let content = `<div class="log-card"><h4 class="category-header">Thread Optimization Results</h4>`;

					optimizeResult.forEach((result, index) => {
						const details = result.details || {};
						const threadName = details.process_name || "N/A";
						const processName = details.process_name || "Unknown";
						const timestamp = details.timestamp || "Unknown";
						const stackTrace = details.stack_trace || "No stack trace available";
						const message = result.message || "";

						// Make unique IDs for buttons
						const terminateBtnId = `terminate-process-btn-${index}`;
						const shutdownBtnId = `shutdown-system-btn-${index}`;

						content += `
										  <div class="log-card" style="margin-top: 1em;">
											<h5>Thread Optimization #${index + 1}</h5>
											<p>${message}</p>
											<ul>
											  <li><strong>Process:</strong> ${processName}</li>
											  <li><strong>Timestamp:</strong> ${timestamp}</li>
											</ul>
											<div class="suggestion-box">
											  <details>
												<summary><strong>Stack Trace</strong></summary>
												<pre>${stackTrace}</pre>
											  </details>
											</div>
											<button class="action-button" id="${terminateBtnId}" style="margin-top: 1em;">Terminate Process</button>
											<button class="action-button" id="${shutdownBtnId}" style="margin-top: 1em;">Shutdown System</button>
										  </div>`;
					});

					content += `
										<div style="margin-top: 1em;">
										  <button class="action-button" onclick="closeThreadModal()">Close</button>
										</div>
									  </div>`;

					container.innerHTML = content;



					optimizeResult.forEach((result, index) => {
						const details = result.details || {};
						const processName = details.process_name;

						const terminateBtn = document.getElementById(`terminate-process-btn-${index}`);
						const shutdownBtn = document.getElementById(`shutdown-system-btn-${index}`);

						if (terminateBtn) {
							terminateBtn.addEventListener("click", async () => {
								try {
									const response = await fetch("/terminate-process", {
										method: "POST",
										headers: { "Content-Type": "application/json" },
										body: JSON.stringify({ process_name: processName })
									});
									const result = await response.json();
									if (result.status === "success") {
										alert(`Process ${processName} terminated successfully.`);
									} else {
										alert(`Failed to terminate process: ${result.message}`);
									}
								} catch (error) {
									alert(`Error terminating process: ${error.message}`);
								}
							});
						}

						if (shutdownBtn) {
							shutdownBtn.addEventListener("click", async () => {
								const confirmed = confirm("Are you sure you want to shutdown the system?");
								if (!confirmed) return;

								try {
									const response = await fetch("/shutdown-system", {
										method: "POST",
										headers: { "Content-Type": "application/json" },
										body: JSON.stringify({ reason: `Requested shutdown due to high CPU from ${processName}` })
									});
									const result = await response.json();
									if (result.status === "success") {
										alert("System shutdown initiated successfully.");
									} else {
										alert(`Failed to initiate system shutdown: ${result.message}`);
									}
								} catch (error) {
									alert(`Error initiating shutdown: ${error.message}`);
								}
							});
						}
					});


				} else {
					container.innerHTML = `
			<div class="log-card">
			  <h4 class="category-header">No Optimization Results</h4>
			  <p>No CPU process issues found to optimize.</p>
			</div>`;
				}

				openThreadModal();

			} catch (error) {
				console.error("Optimization error:", error);
				const container = document.getElementById("thread-details-container");
				container.innerHTML = `
		  <div class="log-card">
			<h4 class="category-header">Error</h4>
			<p>Failed to optimize locks: ${error.message}</p>
		  </div>`;
				openThreadModal();
			}
		}


		let cpuChartInstance = null;
		let cpuProfilerInterval = null;

		async function showCpuProfiler(auto = true) {
			try {
				if (!auto)
				closeAllModals();

				const res = await fetch("/threadProfilerInfo");
				const data = await res.json();

				if (!data.performance_issues || !data.performance_issues.length) {
					document.getElementById("thread-details-container").innerHTML = `
				<div class="log-card">
					<h4 class="category-header">CPU Profiler</h4>
					<p>No CPU trends detected.</p>
				</div>`;
					openThreadModal();
					return;
				}

				const selectedProcess = data.performance_issues[0]; // could make this dynamic
				const threads = selectedProcess.threads;
				const pid = selectedProcess.pid;

				let html = `<h3 class="category-header">CPU Trend per Thread [PID ${pid}]</h3>
			<div class="chart-wrap"><canvas id="cpuTrendChart" height="250"></canvas></div>
			<div style="margin-top: 1em;">
				<button class="action-button" onclick="clearInterval(cpuProfilerInterval); closeThreadModal()">Close</button>
			</div>`;

				document.getElementById("thread-details-container").innerHTML = html;

				const labels = threads[0].timestamps;
				const datasets = threads.map((t, i) => ({
					label: `Thread ${t.thread_id}`,
					data: t.cpu_time,
					fill: false,
					tension: 0.3,
					borderColor: `hsl(${i * 45 % 360}, 80%, 50%)`
				}));

				const ctx = document.getElementById("cpuTrendChart").getContext("2d");

				if (cpuChartInstance) {
					cpuChartInstance.destroy();
				}

				cpuChartInstance = new Chart(ctx, {
					type: "line",
					data: { labels, datasets },
					options: {
						responsive: true,
						animation: false,
						scales: {
							y: { beginAtZero: true, title: { display: true, text: 'CPU Time (ms)' } },
							x: {
								title: { display: true, text: 'Timestamp' },
								type: 'category',
								ticks: {
									autoSkip: true,
									maxRotation: 45,
									minRotation: 45
								}
							}
						},
						plugins: {
							legend: { position: 'bottom' }
						}
					}
				});

				openThreadModal();

				// Auto-refresh every 30 sec
				if (auto && !cpuProfilerInterval) {
					cpuProfilerInterval = setInterval(() => showCpuProfiler(false), 30000);
				}

			} catch (error) {
				console.error("Error in CPU profiler:", error);
				document.getElementById("thread-details-container").innerHTML = `
			<div class="log-card">
				<h4 class="category-header">Error</h4>
				<p>${error.message}</p>
			</div>`;
				openThreadModal();
			}
		}




		async function showCpuProfilerOld() {
			try {
				const response = await fetch("/analyze");
				const data = await response.json();

				const cpuIssues = data.performance_issues.filter(issue => issue.type === "CPU");
				const container = document.getElementById("thread-details-container");

				if (cpuIssues.length === 0) {
					container.innerHTML = `
					<div class="log-card">
						<h4 class="category-header">CPU Profiler</h4>
						<p>No CPU performance issues found.</p>
					</div>`;
				} else {
					let html = `
					<div class="log-card">
						<h4 class="category-header">CPU Profiler</h4>
						<p><strong>Total Issues Detected:</strong> ${cpuIssues.length}</p>
					</div>`;

					cpuIssues.forEach((issue, index) => {
						const stack = (issue.stack_summary && issue.stack_summary.length > 0)
							? issue.stack_summary.join("\n")
							: "No stack trace available";

						html += `
						<div class="log-card" style="margin-top: 1em;">
							<h5>Issue ${index + 1}</h5>
							<ul>
								<li><strong>Message:</strong> ${issue.message}</li>
								<li><strong>Timestamp:</strong> ${issue.timestamp}</li>
							</ul>
							<div class="suggestion-box">
								<details>
									<summary><strong>Stack Trace</strong></summary>
									<pre style="white-space: pre-wrap;">${stack}</pre>
								</details>
							</div>
						</div>`;
					});

					html += `
					<div style="margin-top: 1.5em;">
						<button class="action-button" onclick="closeThreadModal()">Close</button>
					</div>`;

					container.innerHTML = html;
				}

				openThreadModal();
			} catch (error) {
				console.error("Error in CPU profiler:", error);
				const container = document.getElementById("thread-details-container");
				container.innerHTML = `
				<div class="log-card">
					<h4 class="category-header">Error</h4>
					<p>${error.message}</p>
				</div>`;
				openThreadModal();
			}
		}




		async function openDiskProfiler(issueType) {
			const container = document.getElementById("thread-details-container");
			container.innerHTML = `<h4 class="category-header">Loading Disk usage details...</h4>`;

			try {
				closeAllModals();
				document.getElementById("thread-modal").style.display = "block";

				const res = await fetch("/diskInfo");
				const data = await res.json();

				const diskIssues = data.performance_issues.filter(
					item => item.type === "HighDiskUsage" || item.type === "HighDiskIO"
				);

				if (diskIssues.length === 0) {
					container.innerHTML = `<div class="log-card"><p>No disk issues found.</p></div>`;
					return;
				}

				let html = `<h4 class="category-header">Disk Issues (${diskIssues.length})</h4>`;

				diskIssues.forEach(item => {
					html += `
					<div class="log-card thread-entry">
						<p><strong>Type:</strong> ${item.type}</p>
						<p><strong>Message:</strong> ${item.message}</p>
						${item.type === "HighDiskUsage" ? `
							<p><strong>Device:</strong> ${item.device}</p>
							<p><strong>Mountpoint:</strong> ${item.mountpoint}</p>
							<p><strong>Usage:</strong> ${item.usage_percent}% (${item.used_gb} / ${item.total_gb} GB)</p>
						` : `
							<p><strong>Disk:</strong> ${item.disk}</p>
							<p><strong>I/O Rate:</strong> ${item.io_mb_per_sec} MB/s (sample ${item.sample_seconds}s)</p>
						`}
						<p><strong>Timestamp:</strong> ${new Date(item.timestamp).toLocaleString()}</p>
					</div>`;
				});

				container.innerHTML = html;

			} catch (err) {
				container.innerHTML = `<div class="log-card"><p>Error loading disk data: ${err.message}</p></div>`;
			}
		}



		function openThreadModal() {
			const modal = document.getElementById("thread-modal");

			// Show the modal by setting the display style to 'block'
			modal.style.display = "block";
		}

		function closeThreadModal() {
			const modal = document.getElementById("thread-modal");

			// Hide the modal by setting the display style to 'none'
			modal.style.display = "none";
		}

		function analyzeMetrics(metricsArray) {
			const latestByType = {};

			metricsArray.forEach(entry => {
				const timestamp = entry.timestamp;

				// CPU Metrics
				if (entry.cpu_metrics?.critical_processes) {
					entry.cpu_metrics.critical_processes.forEach(proc => {
						const key = `CPU:${proc.name}`;
						if (!latestByType[key] || proc.cpu_percent > latestByType[key].cpu_percent) {
							latestByType[key] = { ...proc, type: 'CPU', timestamp };
						}
					});
				}

				// Deep CPU Metrics
				if (entry.cpu_deep_metrics?.top_cpu_processes) {
					entry.cpu_deep_metrics.top_cpu_processes.forEach(proc => {
						const key = `CPU-Deep:${proc.name}`;
						if (!latestByType[key] || proc.cpu_percent > latestByType[key].cpu_percent) {
							latestByType[key] = { ...proc, type: 'CPU-Deep', timestamp };
						}
					});
				}

				// Memory Metrics
				if (entry.memory_deep_metrics?.top_memory_processes) {
					entry.memory_deep_metrics.top_memory_processes.forEach(proc => {
						const key = `Memory:${proc.name}`;
						if (!latestByType[key] || proc.memory_percent > latestByType[key].memory_percent) {
							latestByType[key] = { ...proc, type: 'Memory', timestamp };
						}
					});
				}

				// Thread Metrics
				if (entry.thread_metrics?.thread_details) {
					entry.thread_metrics.thread_details.forEach(thread => {
						const key = `Thread:${thread.thread_name}`;
						if (!latestByType[key]) {
							latestByType[key] = { ...thread, type: 'Thread', timestamp };
						}
					});
				}
			});

			// Group by type (CPU, Memory, etc.) and return the top entry per group
			const groupedByType = {};
			Object.values(latestByType).forEach(entry => {
				const groupKey = entry.type;
				if (!groupedByType[groupKey]) {
					groupedByType[groupKey] = entry;
				} else {
					const current = groupedByType[groupKey];
					if (
						(entry.cpu_percent && entry.cpu_percent > current.cpu_percent) ||
						(entry.memory_percent && entry.memory_percent > current.memory_percent)
					) {
						groupedByType[groupKey] = entry;
					}
				}
			});

			return groupedByType;
		}

		function toggleBox(header) {
			header.classList.toggle('collapsed');
			const content = header.nextElementSibling;
			const isVisible = content.style.display === 'block';
			content.style.display = isVisible ? 'none' : 'block';
		}

		function toggleAnalysisModal() {
			const modal = document.getElementById("analysisModal");
			modal.style.display = modal.style.display === "block" ? "none" : "block";
		}

		let chart;
		let cpuUsageData = [], memoryUsageData = [], diskUsageData = [], timeStamps = [];
		let threadContentionDetails = [];




        


		function createChart(type = 'line') {
			const ctx = document.getElementById("metricsChart").getContext("2d");
			chart = new Chart(ctx, {
				type: type,
				data: {
					labels: timeStamps,
					datasets: [
						{
							label: "CPU Usage (%)",
							data: cpuUsageData,
							borderColor: "#4caf50",
							backgroundColor: "#4caf5080",
							fill: false
						},
						{
							label: "Memory Usage (%)",
							data: memoryUsageData,
							borderColor: "#90ee90",
							backgroundColor: "#90ee9080",
							fill: false
						},
						{
							label: "Disk Usage (%)",
							data: diskUsageData,
							borderColor: "#ff9800",
							backgroundColor: "#ff980080",
							fill: false
						}
					]
				},
				options: {
					responsive: true,
					scales: {
						x: { title: { display: true, text: 'Time' } },
						y: { min: 0, max: 100, title: { display: true, text: 'Usage (%)' } }
					}
				}
			});
		}

		function updateChart(data) {
			const now = new Date().toLocaleTimeString();
			if (timeStamps.length >= 20) {
				timeStamps.shift();
				cpuUsageData.shift();
				memoryUsageData.shift();
				diskUsageData.shift();
			}

			cpuUsageData.push(data.thread_metrics?.cpu_usage_percent || 0);
			memoryUsageData.push(data.memory_deep_metrics?.memory_usage.percent || 0);
			diskUsageData.push(data.disk_deep_metrics?.disk_usage.percent || 0);
			timeStamps.push(now);

			chart.update();
		}

		function analyzeData() {
			fetchThreadContention();
		}

		function fetchOverallMetrices() {
			fetchMetrics();
		}

		function toggleFullDetails() {
			const modal = document.getElementById("detailsModal");
			modal.style.display = modal.style.display === "block" ? "none" : "block";
		}

		function toggleThreadModal() {
			const modal = document.getElementById("threadModal");
			modal.style.display = modal.style.display === "block" ? "none" : "block";
		}


		function toggleOverviewModal() {
			const modal = document.getElementById("overview-modal");
			modal.style.display = modal.style.display === "block" ? "none" : "block";
		}


		function closeModal(modalId) {
			document.getElementById(modalId).style.display = "none";
		}

		function closeAllModals() {
			document.querySelectorAll(".modal").forEach(modal => modal.style.display = "none");
		}

		function updateChartType() {
			const type = document.getElementById("chart-type").value;
			chart.destroy();
			createChart(type);
		}


	
		



		window.onload = function () {
			createChart();
			setInterval(fetchOverallMetrices, 5000); // Refresh data every 5 seconds by default
		};

		// Toggle dropdown visibility
		notificationIcon.addEventListener('click', () => {
			if (dropdown.style.display === 'none') {
				populateCriticalProcesses();
				dropdown.style.display = 'block';
			} else {
				dropdown.style.display = 'none';
			}
		});

		// Hide dropdown if clicked outside
		window.addEventListener('click', function (event) {
			if (!notificationIcon.contains(event.target) && !dropdown.contains(event.target)) {
				dropdown.style.display = 'none';
			}
		});

	</script>

</body>
</html>
